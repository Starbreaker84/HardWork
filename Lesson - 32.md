## Как проектировать программы in small

Для рефакторинга кода использовался ко-рекурсивный подход, код снабжён комментариями для лучшего понимания.

### Пример 1
Было:
``` Java
public void getPledgeProperties(Application app) {
  // Логика заполнения полей залога в кредитной заявке
}
```

По факту, заполнялись 3 поля кредитной заявки. Проанализировав работу функции, было выделено три новых функции, каждая из которых отвечала за свой параметр.

Стало:
``` Java
public RiskFactor riskFactorProcessFor(Application application) {
  // Бизнес логика расчета риск фактора
  return riskFactor;
}

public PledgeStatus pledgeStatusProcessFor(Application application) {
  // Бизнес логика расчета риск фактора
  return pledgeStatus;
}

public PledgeAccount pledgeAccountProcessFor(Application application) {
  // Бизнес логика расчета риск фактора
  return pledgeAccount;
}
```
В итоге результат собирается из отдельных функций, кодо стал гибче.

### Пример 2
Было:
``` Java
public Dicount getDiscount(Application app) {
  // Логика вычисления объекта бонусов для заполнения полей в кредитной заявке
}
```

По факту, вычислялиcь 2 поля кредитной заявки. Проанализировав работу функции, было выделено две новых функции, каждая из которых отвечала за свой параметр.

Стало:
``` Java
public MaximumPeriod maximumPeriodProcessFor(Application application) {
  // Бизнес логика расчета риск фактора
  return maximumPeriod;
}

public PledgeFine pledgeFineProcessFor(Application application) {
  // Бизнес логика расчета риск фактора
  return pledgeFine;
}
```

Тут аналогично предыдущему примеру результат теперь собирается разными функциями.

### Пример 3
Было:
``` Java
public SaleMessage getSaleMessage(Application app) {
  // Логика формирования сообщения для продакта
}
```

Функция формирования итогового сообщения для работы продакта перед окончательной продажей клиенту.

Стало:
``` Java
public SaleType saleTypeProcessFor(Application app) {
  // Бизнес логика формирования текста сообщения
  return saleType;
}

public Downsale downsaleProcessFor(Application app) {
  // Бизнес логика формирования текста даунсейла
  return downsale;
}
```

Теперь итоговое сообщение формируется по частям, отдельными функциями.

## Итоги:
На самом деле в текущей корпоративной среде в основном применение ко-рекурсивных функций даёт гибкость кода и четкое разделение объекта на составные части, которые в дальнейшем могут быть легко модифицированы. А вот работа со сложными структурами на выходе функций и формирование на их основе итоговой фукгции скорее относится к инфраструктурной разработке, к которой я пока ещё не преступал. Также, я бы наверное добавлял к ко-рекурсивному подходу какой-либо аккумулятор, так как характер рекурсии в Java изначально достаточно конечен. В целом подход видится разумным, но нужно больше практики именно такого стиля, пока у меня его применение ограничено форматом "перекладывания JSON".

## Истинное наследование

### Описание примера:
Мы создадим проект, в котром могут быть разные эелементы, его составляющие (класс, база, тест). Так же у нас будет два вида варианта написания проекта - juior-разработчиком и senior-разработчиком (работа с ними и будет нашими расширениями).

### Вариант с наследованием
Код проекта [тут](https://github.com/Starbreaker84/HardWork/tree/main/Resources/Lesson07/inheritance).

Как сразу видно, при применении наследования, нам приходится описывать логику работы каждого элемента вручную (тут хорошо что мы используем полиморфизм, а то было бы ещё веселее). Пока элементов немного, это не кажется чем-то сложным. Но если представить что элементов много, плюс новый метод содержит обширную логику, то такой подход архитектуры работы проекта станет мягко говоря сложным. Стоит отметить и то, что все расширяемые классы у нас находятся строго в рамках одной иерархии.

### Вариант с применением паттерна Посетитель
Код проекта [тут](https://github.com/Starbreaker84/HardWork/tree/main/Resources/Lesson07/inheritance).

Сразу можно отметить то, что теперь вся логика расширения переместилась в сущности разработчиков (наши Посетители). Таким образом, при необходимости добавления нового метода работы или его варианта, мы всего лишь создаем наследника разработчика, описывает нужное поведение и либо это поведение сразу интегрируется в наш проект либо нам достаточно на сущностях из коллекции добавтить короткий метод, ссылающийся на посетителя (имею ввиду developer.create(this) или подобное. По крайней мере теперь нам не нужно перелопачивать все классы, учавтсвующие в расширении функциональности на предмет добавления новой логики.

## Итоги
Не смотря на то, что в начале паттерн Посетитель кажется достаточно многословным и сложным, при его понимании он раскрывает себя в полной мере. Нужно всего лишь представить что у нас не 2-3 элеента в коллекции, а 100-200, и тогда возможность лишь в одном месте описать всю обширную логику уже не кажется такой уж сложной для понимания.
Стоит отметить ещё одну немаловажную вещь, которую нам позволяет провернуть данный паттерн. Объекты нашей коллекции не должны обязательно принадлежать одной иерархии, мы только должны проследить что для логики расширения у всех объектов будут доступны некоторые общие поля/методы. А это в свою очередь открывает возможности, абсолютно недоступные при наследовании.




## Мутабельность как упрощение модели данных

Представим случай, когда требуется расширить некоторый класс дополнительной фичей, но он уже закрыт для изменений, а создание его нового наследника под небольшое расширение смотрится как стрельба из пушки по воробьям. Полумаем, как реализовать паттерн со словарём: например, требуется добавить в класс A новое поле, и доступ к его значению организовывается через словарь, который в качестве ключа хранит некоторый хэш конкретного объекта.

На моём предыдущем проекте такой подход очень активно использовался в базовой сущности домена, кредитной заявке. Ещё на раннем этапе в сущность было заложено несколько "контейнеров" а-ля temporaryFields (поле с типом Map), в которые можно было сбрасывать "новые" поля по мере необходимости.

Ваш вариант мог бы выглядеть примерно так:
``` Java
public class Employee {
    private UUID id;
    private String name;
    private final Map<String, String> container = new HashMap<>();

    public Employee(UUID id, String name) {
        this.id = id;
        this.name = name;
    }

    public UUID getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void addField(String field, String value) {
        container.put(field, value);
    }

    public String getValueOfField(String field) {
        return container.get(field);
    }
}
```

С учетом скорости доставки новых фич конкретно для этой компании решение работало. Но я обратил внимание на ряд существенных минусов:
1. "Тяжелые" объекты в базе данных по прошествии времени. Это стало прям проблемой, приходилось каждый раз думать как-бы минимизировать поход в базу данных (хотя и использовался GraphQL).
2. Без аналитика разобраться а что там вообще в контейнере не реально, так как по сути это черный ящик, мусорка. Разработчику никогда не известно что за поле может лежать и лежит ли в контейнере, отсюда вытекает множество проверок по коду на наличие или отсутствие искомого поля.
3. В реализации на проекте контейнер мог хранить только строки, и это хорошо. Я даже не представляю какие врата ада бы разверзлись хранись там сущности класса Object.

## Выводы:
Подход может быть удобен при очень быстрой доставки фич, когда затраты времени на расширение класса не оправданы (дерево наследования еще как-то и поддерживать надо). Но у подхода слишком много минусов, которые со временем сделают обращение с таким объектом все более и более ресурснозатратным. Тем не менее в реализации подход простой, есть некий контейнер, в который мы можем свалить все что угодно. В теории, используя классы Java Functional и BiFunctional, можно даже контейнер расширения поведения класса предусмотреть, но лучше конечно более грамотно спроектировать сущности, чем в дальнейшем попасть в неконтролируемое разрастание одной сущности.

## Ясный код - 2

### 2.1. Класс слишком большой (нарушение SRP), или в программе создаётся слишком много его инстансов (подумайте, почему это плохой признак).
``` Java
public class Blog {
    String title = "Microservices";
    String author = "Feynmann";
    public String getTitle() {
        return title;

    public String getAuthor() {
        return author;

    public void printBlog() {
        System.out.println("prints blog");

    public void persist() {
        try {
            FileWriter fw = new FileWriter(getTitle() + "-" + getAuthor() + ".txt");
            fw.write(getTitle() + "-" + getAuthor());
            fw.close();
        } catch (Exception e) {
            System.out.println(e);
}
```
В этом учебном примере налицо нарушение принципа SRP. Для упревления отображением блога и сохранением его состояния несомненно необходиом использовать отдельные классы. Стоит добавить что часто такое происходит когда продолжительное время добавляют новый функционал по чуть-чуть или же в классе начинают копиться константы со статическими методами. 

### 2.2. Класс слишком маленький или делает слишком мало.
``` Java
public class NewClient() {
  
  // Здесь находится конструктор, принимающий датасет клинета

  public Boolean isNewClient(){
    return data.isRkoAndUtilize();
  }
}
```
Рабочий пример. Класс выполняет единственную проверку поля в датасете клиента. Можно было спокойно добавит как функцию в класс, занимающийся исключительно верификацией клиента.

### 2.3. В классе есть метод, который выглядит более подходящим для другого класса.
``` Java
public ClientDataStorageLoader {
  ...

  public externalDataLoad() {
    data.loadActualData();
    opportunity.loadActualDta();
  }  
}
```
Тоже рабочий пример. Есть метод, который явно просится быть разбитым и добавленным в соответствующие классы. Конкретно это тметод обновляет две сущности из своих полей, но ничто не мешает сделать это обновление непосредственно в самих сущностях и на другом этапе.

### 2.4. Класс хранит данные, которые загоняются в него в множестве разных мест в программе.
``` Java
pubic class UtilClass {
  public static Integer currentClients;
  public static Integer currentApplications;
  ...
}
```
Можно сказать что это класический пример утильного класса, в котором могут храниться вспомогательные метрики процесса, при этом заполняются и модифицируются они всегда из самых разных мест программы.

### 2.5. Класс зависит от деталей реализации других классов.
``` Java
public class Blog {
    String title = "Microservices";
    String author = "Feynmann";
    SystemPrinter printer;
    FilePersister persister;

    public Blog (SystemPrinter printer, FilePersister persister) {
      this.printer = printer;
      this.persister = persister;
    }
    public String getTitle() {
        return title;
    }

    public String getAuthor() {
        return author;
    }

    public void printBlog() {
        printer.print(title, author);
    }

    public void persist() {
        try {
            persister.persist(title, author);
        } catch (Exception e) {
            System.out.println(e);
    }
}
```
Классическая реализация сильной связности. Не учитываются такие моменты как изменение способов печати и сохранения состояния (в таком варианте каждый раз вручную придется править код).

### 2.6. Приведение типов вниз по иерархии (родительские классы приводятся к дочерним).
``` Java
public class Storage {
  List<Entity> entitys;
}

// Вызов где-то в коде основной программы

  Case case = storage.getEntity(Case.class);
  Covenant covenant - storage.getEntity(Covenant.class);
```
Тоже рабочий пример. Есть класс Storage, который несколько различных объектов под их родительским классом. Таким образом, при каждом обращении к элементу приходится даункастить его то требуемого типа.

### 2.7. Когда создаётся класс-наследник для какого-то класса, приходится создавать классы-наследники и для некоторых других классов.
``` Java
public class Component1 {
  void print(){}
}

public class Component2 {
  void print(){}
}

public class SubComponent1 extends Component1 {
  @Override
  void print(){}
}

public class SubComponent2 extends Component2 {
  @Override
  void print(){}
}

public class Executor {
  ...
  void toPrinter(){
  //логика печати на принтер
  }

  void toPlotter(){
  //логика печати на плоттер
  }
}
```
Такая ситуация возможно, когда есть какой-то сторонний класс, который использует оба компонента, и при этом в одиночку требует переопределения поведения таких компонентов. В сыром виде это как-раз будет приводить к созданию дочерних классов при каждом переопределении класса-пользователя.

### 2.8. Дочерние классы не используют методы и атрибуты родительских классов, или переопределяют родительские методы.
``` Java
public class Duck {
  public quack() {
  }

  public fly() {
  }
}
```
Хорошим примером будет класс утки. Если мы предположим, что наследники будут не живыми объектами, а например деревянная утка или монок, то, безусловно, такие классы удут полностью переопределять поведение родительского класса. Выходом из этой ситуации могут быть интерфейсы или даже применение паттерна Стратегия.

### 3.1. Одна модификация требует внесения изменений в несколько классов.
``` Java
  public void serialize(this) {
    Util.toJson(this);
  }
```
В данном примере видно, что если нам понадобится сериализовать объект с такой функцией как-то по другому, то придётся перелапачивать всех имплементаторов. Частая ошибка при проектировании на реальных проектах. Как вариант решения проблемы, передавать способ сериализации (класс?) аргументом функции.

### 3.2. Использование сложных паттернов проектирования там, где можно использовать более простой и незамысловатый дизайн. 

Здесь отвечу комментарием. Это довольна частая ошибка новичков (и моя тоже), когда хочется вроде бы системно подойти к решению проблемы, зачастую сильно усложняя код, которому требовалось всего пара методов.

Более того, бизнес требует всегда балансировать между расширяемым и сопровождаемым кодом и тем, которы можно быстро написать и сорповодить в случае необходимости. Вот как раз балансирование зачастую вырабатывает хорошую привычку не усложнять там, где не надо. Но это, к сожалению, приходит только с опытом.

## Фазз-тестирование

Примените для одного из своих проектов фазз-тестирование.

Немного рассказывал о нём тут:

[https://vk.com/wall-152484379_3530](https://vk.com/wall-152484379_3530)

[https://vk.com/wall-152484379_3532](https://vk.com/wall-152484379_3532)

Используйте одну из следующих систем, на выбор (или любую другую :):

afl++

[github.com/AFLplusplus/AFLplusplus](https://github.com/AFLplusplus/AFLplusplus)

libfuzzer

[llvm.org/docs/LibFuzzer.html](https://llvm.org/docs/LibFuzzer.html)

Очень прост в установке в *nix, поскольку встроен в Clang + llvm.

[https://moritz.systems/blog/an-introduction-to-llvm-libfuzzer/](https://www.moritz.systems/blog/an-introduction-to-llvm-libfuzzer/)

ClusterFuzz

[github.com/google/clusterfuzz](https://github.com/google/clusterfuzz)

Быстрое введение в тему:

[habr.com/ru/company/bizone/blog/570312/](https://habr.com/ru/companies/bizone/articles/570312/)

[habr.com/ru/company/dsec/blog/435644/](https://habr.com/ru/companies/dsec/articles/435644/)

В отчёте напишите, какие трудности были при организации фазз-тестирования, на каком языке написан ваш проект, сколько в нём строк кода, и сколько ошибок в нём выявило фазз-тестирование.

##

Изучив представленные платформы (а иначе это не назовёшь, всё-таки фазз-тестироание это как кроличья нора) понял что из списка нет подходящих для Java-проектов. Порывшись в сети нашёл **Jazzer**, прямой наследник LLVM.

Присутствует как CLI клиент для запуска тестов в терминале, так и в виде библиотечной зависимости для написания собственно самих тестов в стиле JUnit (очень удобно).

Теперь непосредственно к проекту.
У меня был один небольшой сервис Rest Api с уже написанными  Unit-тестами. К сожалению, просто из коробки фазз-тесрирование не работает. На свои классы нужно обязательно прописать фазз-тесты, на библиотечные классы всё равно придётся писать небольшой тест внутри проекта. Более того, для качественного тестирования нужно развернуть небольшую инфраструктуру, ключая корпус и т.д.

Тем не менее, для эксперимента сделаем небольшой класс, работающий со стройкой:
``` Java
public class Converter {
    public String encode(String input) {
        return input.chars()
                .mapToObj(c -> (char) (c + 3) )
                .map(Object::toString)
                .collect(Collectors.joining());
    }

    public  String decode(String input) {
        return input.chars()
                .mapToObj(c -> (char) (c - 3))
                .map(Object::toString)
                .collect(Collectors.joining());
    }

}
```

И создадим для него тесты:
``` Java
class ConverterTest {
    @Test
    void converterTest() {
        String input = "abcdf";
        Converter converter = new Converter();
        assertEquals(input, converter.decode(converter.encode(input)));
    }

    @FuzzTest
    void fuzzTest(FuzzedDataProvider data) {
        String input = data.consumeRemainingAsString();
        Converter converter = new Converter();
        assertEquals(input, converter.decode(converter.encode(input)));
    }
}
```
Даже в таком небольшом примере фазз-тестирования произошло 62 698 042 прогонов метода `fuzzTest`. В данном примере ошибок выявлено не было, но и сам пример небольшой.

Как я уже упоминал ранее, к сожалению, из коробки фазз-тестирование не работает, для корректной и эффективной работы необходимо параллеьно с обычным тестированием развернуть дополнительную инфраструктуру для фазз-тестов (хотя она и не столь обременительна). В тоже время, на примере видно, что можно отказаться и от классического unit-тестирования в пользу unit-тестирования с фазз-тестами. По сути, мы в одном методе прогнали несколько десятков тысяч различных вариантов. Сколько времени и разраотчиком понадобится просто чтобы написать такое кол-во вариантов на один метод?

## Итог
Для себя я определил фазз-тестирование как более эффективный метод написания тех же unit-тестов, которые позволят выявить неочевидные способы поведения программы. Целесообразно внедрять фазз-тестирование сразу на начальном этапе разраобтки, чтобы не делать двонйю работу.

Также стоит отметить что и на готовый проект можно внедрить фазз-тестирование, но придётся подготовить минимальную инфраструктуру,включающую как минимум написание базовых тестов на необходимые классы.

В итоге, единственная трудность, это 

P.S. Автотестировние из терминала несовсем авто, так как предполагает что уже существует класс,который содержит фазз-тест. Хотя везде на просторах интернета это преподностися как easy-way for fuzzing.


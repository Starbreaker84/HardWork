## Избавляемся от зависимости от зависимостей

**1. Зависимость от фреймворка.**

В Spring Framework есть механизм AOP, который в том числе позволяет в последствии отследить маршрут прохождения запроса, путём добавления заголовка запроса информации с идентификатором запроса. При этом, фрейворк под капотом использует механизм трассировки, который позволяет проследить за прохождением запроса пользователя через задействованные модули системы.
   
Сделано осознательно.

**2. Зависимость расшаренного формата.**

Постоянно сталкивались с проблемой согласования API между микросервсиными командаим. В итоге пришли к контрактной системе взаимодействия через спецификацию OpenAPI. Теперь API контрактуется стороной инициатором и оформляется в виде .yml файла, и далее путём генерации формируется заготовка для принимающей стороны, и только потом уже пишется реализация.

Сделано осознательно.

**3. Зависимость зависимости.**

Использовали общекомандную библиотеку функционала. Перейдя на очередную новую версию этой библиотеки столкнулись с тем, что наш проект перестал собираться. Проблема оказалась в зависимости от версии GraphQL. У нас использовалась версия чуть более ранняя версия. Как выяснилось, они конфликтовали между собой. Пришлось перейти на новую версию GraphQL и нам.

Сделано осознательно.

**4. Зависимость краша.**

Есть пример, когда соседняя команда доработала функционал, мы обновились на новую версию общей библиотеки и у нас деградировал наш сервис в продакшене, о чём мы узнали от наших пользователей. По итогам изысканий выяснилось, что коллеги допустили баг, из-за которого произошла утечка памяти. В итоге пришлось откатиться на предыдущую версию.

Сделано осознательно.

**5. Зависимость перебрасывания.**

При разработке интеграции со сторонними сервисами по REST часто возникает необходимость сделать заглушку, например, при помощи Mockito. Таким образом имеем две реализации интеграции: продовую и тестовую. Переключение на заглушку происходит при отсутствии доступа к боевому сервису.

Сделано осознательно.

**6. Зависимость инверсии.**

Весь Spring Framework построен на механизме DI для реализации принципе IoC. К сожадению, или к счастью, это уже стандарт в корпоративных приложениях. Как вариант попытки контроля происходящего, более отвественное использование бинов в рамках контейнера, для избежания ситуации краша приложения при отсутствии зависимости в контексте.

Сделано осознательно.

**7. Зависимость зацикливания.**

При использовании Spring Boot новичками частенько натыкался на ситуацию, когда приложение не стартовало, ходя код прекрасно компилировался. Дело было в циклических зависимостях. Когда один бин зависит от другого, тот - от третьего и так далее. В итоге цепочка могла быть длиной в десяток бинов, где последний ссылался в итоге на первый. В результате Spring не мог собрать бины. Выявить такую ситуацию на этапе кодирования достаточно проблематично. Сам стараюсь следовать правилу, когда один бин не должен содержать более трёх зависимостей на другие бины. Это помогает предотвратить описанную ситуацию.

Сделано осознательно.

**8. Зависимость высшего порядка.**

Пример со Spring Data JPA. При реализации своего репозитория легко можно подменить стандартную логику Spring. В итоге будет вызван наш функционал стандартной библиотекой Spring. Чт ои, собственно, происходит в реальных проектах повсеместно. Уйти от зависимости пока проблематично.

Сделано осознательно.

**9. Зависимость большинства**

В команде 4 разработчика. Для того чтобы код был универсальным, в компани принято проводить две проверки кодстайла, во время коммита и во время кодревью вручную по чек листу (достаточно обширному). Также есть линтер во время деплоя. Это позволяет исключить моменты "своего видения" разработчкиами кода и сделать его "универсальным".

Сделано осознательно.


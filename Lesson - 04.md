Нужно сразу оговориться, работы с легаси у меня ещё не было, а тот корпоративный код что есть уже по умолчанию обязан отвечать следованию дизайну (он не такой сложный). Но мы выкрутимся из положения предоставив возможность написать код интересных задач ChatGPT и сделаем рефакторинг в соответствии с дизайном.

## Пример №1:
Задача: написать консольную игру крестики-нолики, учавсвуют два игрока, 
1. Исходный код: [здесь](https://github.com/Starbreaker84/HardWork/blob/main/Resources/Lesson04/original/main.java).
2. Рефлексия: Код написан в стиле "God mode". Все сущности находятся в одном "котле" и жёстко завязаны друг на друга. Любые модификации будут сопряжены с прочёсыванием всей кодовой базы на предмет возможных последствий влияния на поведение всей программы в целом. Код не соответствует дизайну игры, скорее это пример классического "спагетти" кода. Догадаться опосредовано о том, что происходит в коде можно, но достаточно трудно.
3. Код после рефакторинга: [здесь](https://github.com/Starbreaker84/HardWork/tree/main/Resources/Lesson04/refactor)
4. Что изменилось: Теперь мы разделили логику в соответствии с дизайном задачи, а именно, выделили сущности: поля и игровой доски, значения поля, игровой логики и непосредственно запуска приложения.

**Дополнения по рефакторингу кода в соответствии с дизайном**:
- сущности поля и игровой доски - тут всё достаточно тривиально и естественно следует из дизайна задачи;
- игровая логика - выделена в интерфейс (в примере реализована часть игры человека с компьютером), что позволяет в будущем легко добавлять новую логику игры не завися от других компонентов;
- запуск приложения - ну во-первых single responsibility, а во-вторых, данная реализация как раз позволяет нам загружать ту игровую логику что нам нужна в данный момент.

**Итог по примеру**: в целом, уровень абстракции мы подняли ближе к дизайну, что одновременно позволило отвязать компоненты друг от друга, сделать код значительно более гибким для модификации и при этом даже понизило его сложность для восприятия (в общем итоге напишу об этом пункте немного подробнее). Итерация заняла около 25 минут.

## Пример №2:
Задача: написать класс часы, у которого есть три кнопки, третья переключает режимы по кругу, первые две реализуют два методы текущего режима; новые режимы релизим каждый месяц. 
1. Исходный код: [здесь](https://github.com/Starbreaker84/HardWork/blob/main/Resources/Lesson04_2/original/ChatGPTWatch.java).
2. Рефлексия: Снова видим попытку запихнуть всю логику в один класс, что неминуемо ведёт к конфликту в дизайне. Добавление новых режимов - головная боль. Добавление новой кнопки - аналогично. Изменение режима тоже очень сложно. Код жёстко сидит в лучшем случае на втором слое.
3. Код после рефакторинга: [здесь](https://github.com/Starbreaker84/HardWork/tree/main/Resources/Lesson04_2/refactor)
4. Что изменилось: разделили всю логику работы часов в соответствии с дизайном - часы, режимы, действия режимов, переключение реживом. Код стало значительно проще расширять и делать новые режимы - Нужен новый режим, создаём его и добавляем в коллекцию - всё!

**Итог по примеру**: вывели код на третий уровень рассуждения, добившись и отличной читаемости и возможной расширяемости. Итерация заняла около 30 минут.

## Пример №3:
Задача: cоздайте Java-программу, которая позволяет пользователю вводить и сохранять оценки для списка учащихся. Программа должна позволять пользователю добавлять, удалять и обновлять учащихся и оценки для каждого учащегося, а также просматривать оценки для всех учащихся или для конкретного учащегося. 
1. Исходный код: [здесь](https://github.com/Starbreaker84/HardWork/blob/main/Resources/Lesson04_3/original/StudentGradeTracker.java).
2. Рефлексия: опять видим хрдкод но уже на уровне разделения логики по функциям. В целом этот подход жизнеспособен, но практически не расширяем и мы снова не видим дизайна в коде, только реализацию.
3. Код после рефакторинга: [здесь](https://github.com/Starbreaker84/HardWork/tree/main/Resources/Lesson04_3/refactor)
4. Что изменилось: следуя дизайну выделяем сущности нашего приложения и определяем работу строго с ними с макисмально возможной отвязкой друг от друга. Для примера показана реализация трех комманд и хорошо видно что прикрутить в такой компоновке ещё хоть 100 не составит никакого труда. Можно пойти ещё дальше, и отделить сам набор команд в отдельную управляемую сущность, но тут уже надо использовать фреймворк для управления инстантсами объектов и реализации DI (да-да, я про Spring Framework).

**Итог по примеру**: вот тут мне кажется следование дизайну постепенно начинает усложнять код, нам приходится писать больше кода в угоду расширяемости и управляемоссти, но в тоже время, применение фреймворка решит и эту проблему. Итерация заняла около 2 часов.

## Общий итог:
Не знаю как для остальных, но для меня максимальное следование дизайну кажется крайне ествественным. Поднимаясь всё выше и выше в абстракции при должном внимании к сложности мы решаем много проблем, так характерных для второго слоя думания о программе. Удивительно, но к этой концепции я раньше пришёл сам, и сейчас она помогает мне писать хорошо и читаемый и поддерживаемый и расширяемый код. Всегда стараюсь думать о своём коде именно в этом ключе. Конечно иногда сложност выходит из подконтроля, но тогда нужно останоситься, сделать шаг назад, всё обдумать и возможно прийти к решению что уже достаточно.

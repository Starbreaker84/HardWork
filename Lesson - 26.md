## Ускоряем код фреймворков в 100 раз

Основная идея заключается в том, чтобы четко понимать что ожидает клиент и что мы в итооге ему отдаем. Сюда входят как и структуры данных, которые мы возвращаем, так и сами сущности.

### Пример 1

Между фронтэндом и бэкендом отсутсвовала договорённость об упорядоченности структуры данных. При этом бэкенд возвращал List сущностей, и мной предполагалось что там наверняка будет лежать упорядоченый список. Из-за этого, в слое сервиса чуть не была допущена ошибка, которая могла возникнуть из-за такого непроверенного предположения. Заменив структуру ответа с List на Set я избавился в коде от двусмысленности, четко обозначив отсутствие в контракте упорядоченности.

### Пример 2

Отсутсвие возможности пагинации при ответе клиенту. Пока таблица сущностей была небольшой и отдавался просто упорядоченный List, проблем не возникало. Но как только таблица начала быстро разрастаться, время запроса и обработки на фронте начали стремительно увеличиваться. При этом в документации нигде не было указано что метод начет возвращать всю базу сущностей. Конечно, мне следовало для начала выснить как на самом деле работает метод. Во-первых, мною была добавлена возможность отдавать не только List, но и Page, что значительно выровняло работу приложения, плюс, осталась возможность отдавать List, но при условии наличия дополнительного критерия в запросе, чтобы значительно сузить выборку.

### Пример 3

При отдаче результата исполнения запроса вызывался слой сервиса с очень путанной логикойобработки результата. Запросы проходили медленно. Пришлось лезть в "кишки" и разбираться что к чему. Выяснилось, что сложная логика сервисного слоя могла быть спокойно заменена на результат выполнения агрригирующих фукнций. При этом в оригинальной версии репозиторий отдавал список объектов, непонятно как связанных. После того как я создал отдельную сущность для результата агрегации функции и репозиторий начал отдавать именно её, и работа приложения выровнялась и из структуры кода стало чётко ясно что конретно отдаёт клиенту репозиторий.

## Вывод:
Точное обозначение сущности отдачи результата и чёткое понимание в какой структуре данных это должно быть отдано в соответствии с контрактами, позволяет находу "читать" спецификацию кода и не делать ложных предположений, которые могут в последствии вызвать ошибки. Конечно это по-началу будет требовать больше времени на анализ и проработку, зато со временм окупится сторицей, когда код будет говорить сам за себя.
. 

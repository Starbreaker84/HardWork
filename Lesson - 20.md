## Концепция:
Внедрение парадигмы иммутабельного состояния представляет собой перспективный шаг в разработке программных проектов, стремящихся к оптимизации и уменьшению косвенных зависимостей. Неоспоримо, что использование неизменяемых структур данных способно значительно упростить проект, а также повысить его надежность.

Однако, следует отметить, что этот подход не обходится без некоторых компромиссов. Помимо явного упрощения кода, неизменяемость вносит дополнительные требования к использованию памяти. В мире мутабельности, где значения передаются по ссылке, активно применяется концепция sharing и совместного использования данных в нескольких точках программы. С этим неизбежно связан рост потребления памяти, что, тем не менее, может считаться небольшой ценой за повышенную надежность и предсказуемость системы.

Таким образом, решение о внедрении иммутабельности в проект следует взвешивать, учитывая его конкретные требования и ориентиры, а также принимая в расчет баланс между упрощением структуры кода и дополнительными издержками по памяти.

## Примеры:
### Пример 1
Промышленный код, связанный с техническим обеспечением бизнес-логики (код приведен не весь, но достаточный для демонстрации идеи).
### Было:
``` Java
public class Resolver {
    private List<String> resolvers = List.of("MAIL", "PROCESS", "CLIENT");

    public List<String> getResolvers() {
        return resolvers;
    }
}
```
### Стало:
``` Java
public class Resolver {
    private List<String> resolvers = List.of("MAIL", "PROCESS", "CLIENT");

    public List<String> getResolvers() {
        return List.copyOf(resolvers);
    }
}
```
Для того, чтобы исключить влияние пользоватея класса на список, который был бы передан ссылкой (и соответствено, мог быть изменен стандартными методами) в ответе метода передаётся его копия ( а точнее другая ссылку на копию данных), и даже если пользователь класса попытается его поменять, никакого эффекта на класс Resolver это уже не окажет.
### Пример 2
В стремлении к избавлению от проблем, связанных с мутабельным состоянием, полезно рассмотреть практический пример, который подчеркивает важность создания неизменяемых объектов. Рассмотрим ситуацию, когда в конструкторе класса принимается объект по ссылке, например, список разрешений. В таком случае рекомендуется создавать копию принятого объекта. Это позволяет обеспечить стабильность и непроницаемость создаваемого класса. Например, если класс А создается через конструктор, принимающий объект класса Б, предпринимаемые меры копирования объекта Б предотвращают возможность изменения класса Б после создания объекта А. Такой подход способствует поддержанию непрерывности исходного состояния объектов, снижая вероятность нежелательных изменений и упрощая общую структуру программы.

### Пример 3
Пример, демонстрирующий передачу копии целого класса.
``` Java
public class DepartmentLaptops {
    private List<Laptop> laptops;

    public Laptop getLaptop(String laptopId) {
        return laptops.stream()
                .filter(laptop -> laptop.getId().equals(laptopId))
                .reduce((a, b) -> {
                    throw new IllegalStateException("Too many elements match the predicate");
                })
                .map(Laptop::getCopy)
                .orElseThrow(() -> new IllegalStateException("No element matches the predicate"));
    }
}
```
Тут мы видим что при передаче элемента из списка передается не ссылка на элемент, а его точная копия, реализованная с помощью соответствующего метода. Цель все таже - защита от вмешательства в сущности потенциальных пользователей.
